function [param]=coregfit(d,V,o,model,param0,options);% coregfit                  - fitting of the coregionalization model (Jan 1,2001)%% Use an iterated least squares based algorithm for fitting a% multivariate model of variograms or covariance functions that% have been estimated using the vario.m or covario.m function.% This joint model is also called the Linear Model of% Coregionalization. The various modeled (cross)variograms or% (cross)covariance functions are defined as a sum of the same% few basic models having identical parameters for all variables% except for the sill parameters (or the equivalent of the sill% parameters for variogram models).%% SYNTAX :%% [param]=coregfit(d,V,o,model,param0,options);%% INPUT :%% d         nc by 1     vector giving the sorted values of the mean distance separating%                       the pairs of points that belong to the same distance class. % V         nv by nv    symmetric array of cells that contains the variograms and cross%                       variograms estimates, or the covariance and cross covariance%                       estimates, for the distance classes specified in d.%                       Diagonal cells contain the variograms or covariance, whereas%                       off-diagonal cells contain the cross variograms or covariances.%                       If Z is a column vector (only one variable), then V is simply a%                       column vector having same size as d.% o         nc by 1     vector giving the number of pairs of points that belong to the %                       corresponding distance classes.% model     string      that contains the name of the variogram or covariance model for%                       which parameters are sought (see the MODELS directory for possible%                       names of variograms and covariance functions). % param0    1 by k      initial guess values for the parameters of model, according to the%                       convention for the corresponding variogram or covariance model. As%                       the coregfit.m function only seeks for estimates of the sill parameter%                       of model for the different variables, the first value in param0 is%                       arbitrary. The other parameters are kept unchanged by the function.% options   1 by 1 or 5 vector of optional parameters that can be used if default values are%                       not satisfactory (otherwise this vector can simply be omitted from the%                       input list of variables), where :%                       options(1) displays the estimated and fitted multivariate models if%                       the value is set to one (default value is 0),%                       options(2) is the relative tolerance for the fitting (default value%                       is 1e-4),%                       options(3) is the maximum number of iterations (default value is 1000),%                       options(4) is 0 for ordinary least squares and 1 for weighted least%                       squares, where the weights are proportional to the number of pairs of%                       points in each distance class (default value is 1),%                       options(5) is 0 for least squares based solely on the variograms%                       (covariance functions), and is 1 for least squares fitting based on%                       cross variograms (cross covariance functions) too (default value is 1).% OUTPUT :%% param     1 by 2      cell array that contains the complete set of parameters (both estimated%                       and unchanged) associated with model (see the detailed description%                       given for kriging.m about the coding of these parameters for the various%                       possible cases).%% NOTE :%% For a detailed discussion about the coding of the model and param0% variables for nested models, the reader is referred to the detailed% description given for the kriging.m function. The model and param% output variables are formatted in a way that the user can use them% as input model and param variables for the kriging.m and associated% functions.%%%%%% Check if there are no NaNif length(find(isnan(d))),  error('Some distance classes do not contain pairs of points');end;%%%%%% Initialize the parameters if nargin<6,            % setup the default options if not provided  options(1)=0;  options(2)=1e-4;  options(3)=1000;  options(4)=1;  options(5)=1;else  noptions=length(options);  if noptions==1,    options(2)=1e-4;    options(3)=1000;    options(4)=1;    options(5)=1;  end;end;if iscell(V)==1,        % test if there is one variable  nv=size(V,1);         % nv is the number of variables  onevariable=0;else  nv=1;  V={V};                % create a cell with the content of vector V  onevariable=1;end;nd=length(d);           % nd is the number of distance classesif iscell(model)==0,                      % if there is one model, create a second  np=length(param0);                      % identical one, evaluate the theoretical  g=eval([model,'(d,[1,param0(2:np)])']); % value at distances d and set onemodel=1   g=[g g];  nm=2;  onemodel=1;else                                      % else evaluate the theoretical values at  nm=length(model);                       % distance d and set onemodel=0  g=zeros(nd,nm);  for i=1:nm,    np=length(param0{i});    g(:,i)=eval([model{i},'(d,[1,param0{i}(2:np)])']);  end;  onemodel=0;end;if options(4)==1,       % if weighted least squares is required  w=o/sum(o);           % set the weights proportional to theelse                    % mean number of pairs of points  w=ones(nd,1)/nd;      % else ordinary least squares is requiredend;                    % and the weigths are set equal to 1/ndCinit=zeros(nv,nv);for i=1:nv,             % define a diagonal initialization matrix  for j=1:nv,           % of coefficients    if i==j,      Cinit(i,i)=mean(V{i,i});    end;  end;end;C=cell(nm,1);for i=1:nm,             % set the initial matrix of C equal to the  C{i}=Cinit/nm;        % initialization matrix divided by the end;                    % number of variogram models%%%%%% Iterations over the different structures iter=0;test=1;WSSold=inf;while ((test==1)&(iter<options(3))),  iter=iter+1;  for i=1:nm,    index=1:nm;    index(i)=[];    gt=g(:,index);    gi=g(:,i);    Ct=C(index);    dVt=cell(nv,nv);    for j=1:nv,      for k=j:nv,        dVt{j,k}=V{j,k};        for l=1:nm-1,           dVt{j,k}=dVt{j,k}-gt(:,l)*Ct{l}(j,k);        end;      end;    end;    for j=1:nv,      for k=j:nv,        Ctemp(j,k)=(w.*gi)'*dVt{j,k};        Ctemp(k,j)=Ctemp(j,k);      end;    end;    [Q,S]=eig(Ctemp);    S=diag(S);    condi=(S<=0);    S=S.*(~condi);    S=S+condi*0.001*min(S(~condi));    S=diag(S);    Ctemp=Q*S*Q';    C{i}=Ctemp/(w'*(g(:,i).^2));  end;   %%%%%% Compute the fitting criterion  WSS=0;  if options(5)==1,    for i=1:nm      for j=1:nv        for k=j:nv,          WSS=WSS+sum((w.*(V{j,k}-g(:,i)*C{i}(j,k))).^2);	  if onemodel==1,	    WSS=WSS/2;          end;        end      end;    end;  else    for i=1:nm      for j=1:nv        WSS=WSS+sum((w.*(V{j,j}-g(:,i)*C{i}(j,j))).^2);      end;    end;  end;  if abs((WSSold-WSS)/WSSold)<options(2),    test=0;  end;  WSSold=WSS;end;if onemodel==1,  C=C{1}+C{2};  C={C};  nm=1;end;%%%%%% Display the fitting results if options(1)==1,  test=(ishold==1);  for i=1:nv,    for j=i:nv,      minVij=min(V{i,j});      maxVij=max(V{i,j});      vfit=zeros(nd,1);      for k=1:nm,        vfit=vfit+C{k}(i,j)*g(:,k);       end;      subplot(nv,nv,(i-1)*nv+j);      plot(d,V{i,j},'.');hold on;      plot(d,vfit);      set(gca,'FontSize',6);      axis([0 max(d) min([0;-1.1*sign(minVij)*minVij]) max([0;1.1*sign(maxVij)*maxVij])]);       plot([0 max(d)],[0 0],':');         xlabel('Distance','FontSize',8);      ylabel('Variogram-Covariance','FontSize',8);      title(['Couple ',num2str(i),'-',num2str(j)'],'FontSize',8);    end;  end;  if test==0,    hold off;  end;end;%%%%%% Build the paramfit array of cellsif onemodel==1,  if onevariable==1,    param=[C{1} param0(2:np)];  else    param={C{1},param0(2:np)};  end;else  for i=1:nm,    np=length(param0{i});    param{i}={C{i},param0{i}(2:np)};  end;end;