function [yk,info]=BMEintervalTMode(ck,ch,cs,yh,a,b,covmodel,covparam,nhmax,nsmax,dmax,yfile,cdfyfile,options);% BMEintervalTMode          - BME mode prediction with transform and interval data (Jan 1,2001)%% Provide BME estimates when data cannot reasonably be assumed as% Gaussian distributed. As BME based on the raw data will not% provide very satisfactory results, a solution is to first% transform the data to make them at least marginally Gaussian% distributed, then to perform the estimation on the Gaussian scale,% and finally to back transform these estimates on the original scale.% The estimates correspond to the mode of the posterior distribution% on the original scale. This function is closely related to krigingT.m% and BMEintervalMode.m. %% SYNTAX :%% [yk,info]=BMEintervalTMode(ck,ch,cs,yh,a,b,covmodel,covparam,nhmax,nsmax,dmax,yfile,cdfyfile,options);%% INPUT :%% ck         nk by d      matrix of coordinates for the estimation locations.%                         A line corresponds to the vector of coordinates at%                         an estimation location, so the number of columns%                         corresponds to the dimension of the space. There is%                         no restriction on the dimension of the space.% ch         nh by d      matrix of coordinates for the hard data locations,%                         with the same convention as for ck.% cs         ns by d      matrix of coordinates for the soft data locations,%                         with the same convention as for ck.% yh         nh by 1      vector of values on the original (non-Gaussian) scale%                         for the hard data at the coordinates specified in ch.% a          ns by 1      vector of values on the original (non-Gaussian) scale%                         for the lower bound of the intervals at the coordinates%                         specified in cs.% b          ns by 1      vector of values on the original (non-Gaussian) scale%                         for the upper bound of the intervals at the coordinates%                         specified in cs.% covmodel   string       that contains the name of the covariance model that is%                         used for estimation on the Gaussian scale. If this model%                         has to be estimated from the data, it is needed to%                         transform the data on the Gaussian scale prior to its%                         estimation (see other2gauss.m).% covparam   1 by k       vector of values for the parameters of covmodel, according%                         to the convention for the corresponding covariance model.% nhmax      scalar       maximum number of hard data values that are considered%                         for the estimation at the locations specified in ck.% nsmax      scalar       maximum number of soft data values that are considered for%                         the estimation at the locations specified in ck. As the%                         computation time is exponentially increasing with nsmax,%                         it is not advised to use more than few soft data locations.%                         In any case, nsmax should be lower than 20 in order to%                         avoid numerical computation problems.% dmax       scalar       maximum distance between an estimation location and%                         existing hard/soft data locations. All hard/soft data%                         locations separated by a distance smaller than dmax from an%                         estimation location will be included in the estimation process%                         for that location, whereas other data locations are neglected.% yfile      m by 1       vector of values sorted in ascending order for which the%                         cumulative distribution distribution is provided on the original%                         scale. It is recommended to have a finely discretized set of%                         values, so computations can be realized on a fine scale.% cdfyfile   m by 1       vector of values for the cumulative distribution function at the%                         yfile values.% options    1 by 1 or 14 vector of optional parameters that can be used if default%                         values are not satisfactory (otherwise this vector can simply be%                         omitted from the input list of variables), where :%                         options(1), options(2) and options(14) are values used by the%                         fminbnd.m MATLAB optimization routine that finds the mode of the%                         probability distribution function (default values are the same%                         as for fminbnd.m),%                         options(3) specifies the maximum number of evaluation that can%                         be done by the FORTRAN77 subroutines for the integrals (default%                         value is 50 000 ; this value should be increased if a warning%                         message appears on the screen during the computation),%                         options(4) specifies the maximum admissible relative error on the%                         estimation of these integrals (default value is 1e-4). The values%                         for options(5) to options(13) are not used.%% OUTPUT :%% yk         nk by 1      vector of the estimated mode values on the original scale at the%                         estimation locations. A value coded as NaN means that no estimation%                         has been performed at that location, due to the lack of available%                         data.% info       nk by 1      vector for information about the computation of estimated values.%                         Different possible values are :%                         info=NaN if there is no computation at all (no hard and soft data%                         are available around or at the estimation location),%                         info=0 when computation is made using BME with at least 1 soft data,%                         info=1 when the estimation is dubious due to an integration error%                         above the tolerance specified in options(4),%                         info=2 when the estimation is dubious as the result did not converge%                         within the maximum number of iterations specified in options(14),%                         info=3 when the computation is made using kriging with no soft data,%                         info=4 when there is a hard data value at the estimation location,%                         info=5 when there is only an interval at the estimation location.%                         (the output yk value is then the middle of this interval).%% NOTE :%% 1- As the function computes the mode of the posterior probability% distribution function using the derivative of the transformation% function, it is very highly recommended that the cumulative% distribution function specified in cdfyfile is at least twice% differentiable (i.e., the corresponding probability distribution% function is differentiable). This property makes sure that the% transformed posterior probability distribution function in the% original domain is smooth, so that the mode of the distribution% can be easily identified. It is thus not advised to use an empirical% cumulative distribution function as provided by the cdfest.m function,% which is expected to be not smooth at all. Instead, an estimate of% the cumulative distribution function as provided by kernelsmoothing.m% or a discrete definition of a differentiable parametric distribution% is to be preferred.%% 2- Using BMEintervalTMode.m requires that the variable has a% constant mean. If this hypothesis does not hold, it is necessary% to remove first the values of the mean from the yh vector. This% can be done using, e.g., the regression.m or the kernelregression.m% functions).%% 3- If there are several variables to be processed at the same time% (see the multivariate case described in kriging.m), the yfile and% cdfyfile variables must be defined as 1 by nv cell arrays, where% each cell corresponds to the definition of the distribution for the% corresponding variable. %% 4- Note that in the case there are no available hard data at all,% ch and zh can be entered as the empty [ ] matrices.%% 5-  All the specific conventions for specifying nested models,% multivariate or space-time cases are the same as for BMEprobaMoments.m.%%%%%% Error messagesif sum(nsmax)>20,  error('sum(nsmax) must not exceed 20');end;%%%%%% Initialize the parametersglobal INFOINTEG      % information message from the Fortran subroutineif nargin<14,         % initialize options with default values  options(1)=0;  options1=0;  options(2)=1e-4;  options(14)=500;  options(3)=50000;  options(4)=1e-4;else  options1=options(1);  options(1)=0;end;if length(options)<2 | ~options(2)  options(2)=1e-4;end  TolX=options(2);if length(options)<14 | ~options(14)  options(14)=500;end  MaxFunEvals=options(14);fminbndoptions = optimset('Display','off','TolX',TolX,'MaxFunEvals',MaxFunEvals);noindex=~iscell(ck);       % test if there is an index for the variablesif noindex==1,  nk=size(ck,1);           % nk is the number of estimation points  nh=size(ch,1);           % nh is the number of hard data  ns=size(cs,1);           % ns is the number of soft dataelse  nk=size(ck{1},1);  nindexk=length(ck{2});  if nindexk==1,    ck{2}=ck{2}*ones(nk,1);  end;  nh=size(ch{1},1);  ns=size(cs{1},1);end;if options1==1,  num2strnk=num2str(nk);end;yk=zeros(nk,1)*NaN;info=zeros(nk,1)*NaN;%%%%%% Transform the y values to Gaussian-distributed valuesif noindex==1,  indexk=ones(nk,1);  indexh=1;  indexs=1;  zh=other2gauss(yh,yfile,cdfyfile);  a=other2gauss(a,yfile,cdfyfile);  b=other2gauss(b,yfile,cdfyfile);  yfile={yfile};  cdfyfile={cdfyfile};else  indexk=ck{2};  indexh=ch{2};  indexs=cs{2};  zh=other2gauss({yh,indexh},yfile,cdfyfile);  a=other2gauss({a,indexs},yfile,cdfyfile);  b=other2gauss({b,indexs},yfile,cdfyfile);end;%%%%%% Compute the derivative of the transformsmaxindex=max([indexk;indexh;indexs]);dgfile=cell(1,maxindex);zfile=cell(1,maxindex);for i=1:maxindex,  dgfile{i}=transformderiv(yfile{i},cdfyfile{i});  zfile{i}=other2gauss({yfile{i},i},yfile,cdfyfile);end;%%%%%% Main loop starts herefor i=1:nk,  if noindex==1,    ck0=ck(i,:);  else    ck0={ck{1}(i,:),ck{2}(i)};  end;  %%%%%% Select the local neighbourhood for all variables  [chlocal,zhlocal,dh,sumnhlocal]=neighbours(ck0,ch,zh,nhmax,dmax);  [cslocal,ablocal,ds,sumnslocal]=neighbours(ck0,cs,[a b],nsmax,dmax);  if ~isempty(ablocal),    alocal=ablocal(:,1);blocal=ablocal(:,2);  else    alocal=[];blocal=[];  end;  %%%%%% Test if there is a hard data at estimation point  iscomputed=0;  [index]=findpairs(ck0,chlocal);                % test if there is a hard data at estimation point  if ~isempty(index),    zk=zhlocal(index(2));                        % return the hard data value as the estimate    yk(i)=interp1(zfile{indexk(i)},yfile{indexk(i)},zk,'linear');    info(i)=4;                                   % set the value of info to 4     iscomputed=1;                                % specify that the value has been computed  end;  %%%%%% Test if there is a soft data at estimation point  isduplicate=0;  [index]=findpairs(ck0,cslocal);                % if there is a soft data at estimation point,  if ~isempty(index),                            % split the soft data into two sets    [csest,cslocal,abest,ablocal]=split(cslocal,[alocal blocal],index(2));    alocal=ablocal(:,1);    blocal=ablocal(:,2);    aest=abest(:,1);    best=abest(:,2);    sumnslocal=sumnslocal-1;    isduplicate=1;                               % specify that there is a soft data at estimation point  end;  %%%%%% Returns NaN or the middle of the interval when (sumnhlocal=0)&(sumnslocal==0)&(iscomputed==0)  if (sumnhlocal==0)&(sumnslocal==0)&(iscomputed==0),    if isduplicate==1,      aback=interp1(zfile{indexk(i)},yfile{indexk(i)},aest,'linear');      bback=interp1(zfile{indexk(i)},yfile{indexk(i)},best,'linear');      yk(i)=(aback+bback)/2;      info(i)=5;    else      yk(i)=NaN;        info(i)=NaN;    end;  end;  %%%%%% Returns the simple cokriging estimate when sumnslocal==0  if (sumnhlocal>0)&(sumnslocal==0)&(iscomputed==0),    K=coord2K(chlocal,chlocal,covmodel,covparam);   % built the left-hand side matrix    k=coord2K(chlocal,ck0,covmodel,covparam);       % built the right-hand side vector    lam=K\k;                                        % compute the kriging weights lam    lamt=lam';    zk=lamt*zhlocal;                                % compute the kriging estimates zk    vk=K(1,1)-2*lamt*k+lamt*K*lam;                  % and the kriging variance vk    if isduplicate==1,      zkmin=aest;      zkmax=best;    else      zkmin=gaussinv(0,[zk vk]) ;      zkmax=gaussinv(1,[zk vk]) ;    end;    [zk,FVAL,EXITFLAG,OUTPUT]=fminbnd(@fminBMEintervalTModeSK,zkmin,zkmax,fminbndoptions,...      zk,vk,zfile{indexk(i)},dgfile{indexk(i)});    options(10)=OUTPUT.funcCount;           yk(i)=interp1(zfile{indexk(i)},yfile{indexk(i)},zk,'linear');    info(i)=3;  end;  %%%%%% Returns the BME estimate when sumnslocal>0  if (sumnslocal>0)&(iscomputed==0),    Kkk=coord2K(ck0,ck0,covmodel,covparam);         % compute variance for estimation point    Khh=coord2K(chlocal,chlocal,covmodel,covparam); % compute covariance matrix for hard data    Kss=coord2K(cslocal,cslocal,covmodel,covparam); % compute covariance matrix for soft data    Kkh=coord2K(ck0,chlocal,covmodel,covparam);     % compute cross-covariance vector estimation/hard data    Kks=coord2K(ck0,cslocal,covmodel,covparam);     % compute cross-covariance vector estimation/soft data    Ksh=coord2K(cslocal,chlocal,covmodel,covparam); % compute cross-covariance matrix soft/hard data    Kkhkh=[[Kkk,Kkh];[Kkh',Khh]];                   % build estimation+hard data covariance matrix    Kskh=[Kks',Ksh];                                % build cross-covariance matrix soft/estimation+hard data    invKkhkh=inv(Kkhkh);    KskhinvKkhkh=Kskh*invKkhkh;    Kssifkh=Kss-KskhinvKkhkh*Kskh';                 % compute the conditional covariance matrix    if isduplicate==1,      zkmin=aest;      zkmax=best;    else      zkmin=min([zhlocal;alocal;0]);                % initialize the minimum and maximum guess      zkmax=max([zhlocal;blocal;0]);                % values to be used by fminbnd    end;    [zk,FVAL,EXITFLAG,OUTPUT]=fminbnd(@fminBMEintervalTModeBME,zkmin,zkmax,fminbndoptions,...      zhlocal,alocal,blocal,invKkhkh,KskhinvKkhkh,Kssifkh,zfile{indexk(i)},...      dgfile{indexk(i)},options);    options(10)=OUTPUT.funcCount;    yk(i)=interp1(zfile{indexk(i)},yfile{indexk(i)},zk,'linear');    %%%%%% Select the appropriate info value    if options(10)>=options(14),       info(i)=2;    else      if INFOINTEG==0,info(i)=0;end;      if INFOINTEG==1,info(i)=1;end    end;  end;  if options1==1,    disp([num2str(i),'/',num2strnk]);  end;end;